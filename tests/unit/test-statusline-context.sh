#!/bin/bash
# test-statusline-context.sh - Unit tests for statusline context display
#
# VERSION: 1.0.0
#
# Validates that statusline CtxUse values match /context command output
# Uses cache file generated by statusline-ralph.sh
#
# Usage:
#   ./test-statusline-context.sh                    # Run all tests
#   ./test-statusline-context.sh validate           # Validate against /context
#   ./test-statusline-context.sh validate 133000 200000 66  # With /context values
#
# Requirements:
#   - statusline-ralph.sh must be running (generates cache)
#   - Cache file: /tmp/ralph-statusline-context.json

set -e

# Test configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
STATUSLINE_SCRIPT="$PROJECT_ROOT/.claude/scripts/statusline-ralph.sh"
CACHE_FILE="/tmp/ralph-statusline-context.json"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
DIM='\033[2m'
RESET='\033[0m'

# Test counters
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_TOTAL=0

# Helper functions
log_test() {
    echo -e "${CYAN}[TEST]${RESET} $1"
}

log_pass() {
    ((TESTS_PASSED++))
    ((TESTS_TOTAL++))
    echo -e "  ${GREEN}✓ PASS${RESET} $1"
}

log_fail() {
    ((TESTS_FAILED++))
    ((TESTS_TOTAL++))
    echo -e "  ${RED}✗ FAIL${RESET} $1"
    if [[ -n "$2" ]]; then
        echo -e "         ${DIM}Expected: $2${RESET}"
        echo -e "         ${DIM}Got: $3${RESET}"
    fi
}

log_skip() {
    ((TESTS_TOTAL++))
    echo -e "  ${YELLOW}⊘ SKIP${RESET} $1"
}

# ============================================
# UNIT TESTS
# ============================================

test_cache_file_exists() {
    log_test "Cache file exists"

    if [[ -f "$CACHE_FILE" ]]; then
        log_pass "Cache file found at $CACHE_FILE"
    else
        log_fail "Cache file not found" "$CACHE_FILE" "No file"
        echo -e "  ${DIM}Run Claude Code session first to generate cache${RESET}"
    fi
}

test_cache_file_valid_json() {
    log_test "Cache file is valid JSON"

    if [[ ! -f "$CACHE_FILE" ]]; then
        log_skip "Cache file doesn't exist"
        return
    fi

    if jq empty "$CACHE_FILE" 2>/dev/null; then
        log_pass "Valid JSON structure"
    else
        log_fail "Invalid JSON" "Valid JSON" "Parse error"
    fi
}

test_cache_has_required_fields() {
    log_test "Cache has required fields"

    if [[ ! -f "$CACHE_FILE" ]]; then
        log_skip "Cache file doesn't exist"
        return
    fi

    local has_used=0
    local has_total=0
    local has_pct=0
    local has_remaining=0

    jq -e '.used_tokens' "$CACHE_FILE" >/dev/null 2>&1 && has_used=1
    jq -e '.total_tokens' "$CACHE_FILE" >/dev/null 2>&1 && has_total=1
    jq -e '.percentage' "$CACHE_FILE" >/dev/null 2>&1 && has_pct=1
    jq -e '.remaining_percentage' "$CACHE_FILE" >/dev/null 2>&1 && has_remaining=1

    if [[ $has_used -eq 1 && $has_total -eq 1 && $has_pct -eq 1 ]]; then
        log_pass "All required fields present (used_tokens, total_tokens, percentage)"
        if [[ $has_remaining -eq 1 ]]; then
            echo -e "         ${DIM}+ remaining_percentage field (v2.81.2)${RESET}"
        fi
    else
        [[ $has_used -eq 0 ]] && log_fail "Missing used_tokens field"
        [[ $has_total -eq 0 ]] && log_fail "Missing total_tokens field"
        [[ $has_pct -eq 0 ]] && log_fail "Missing percentage field"
    fi
}

test_remaining_percentage_matches() {
    log_test "remaining_percentage calculation matches /context"

    if [[ ! -f "$CACHE_FILE" ]]; then
        log_skip "Cache file doesn't exist"
        return
    fi

    local remaining=$(jq -r '.remaining_percentage // null' "$CACHE_FILE")
    local pct=$(jq -r '.percentage // 0' "$CACHE_FILE")

    if [[ "$remaining" == "null" ]]; then
        log_skip "No remaining_percentage in cache (using fallback calculation)"
        return
    fi

    local expected_pct=$((100 - remaining))
    local diff=$((pct - expected_pct))
    [[ $diff -lt 0 ]] && diff=$((-diff))

    if [[ $diff -le 1 ]]; then
        log_pass "remaining_percentage matches (${remaining}% left = ${pct}% used)"
    else
        log_fail "remaining_percentage mismatch" "${expected_pct}%" "${pct}%"
    fi
}

test_values_in_valid_range() {
    log_test "Values are in valid range"

    if [[ ! -f "$CACHE_FILE" ]]; then
        log_skip "Cache file doesn't exist"
        return
    fi

    local used=$(jq -r '.used_tokens // -1' "$CACHE_FILE")
    local total=$(jq -r '.total_tokens // -1' "$CACHE_FILE")
    local pct=$(jq -r '.percentage // -1' "$CACHE_FILE")

    local all_valid=true

    # Used tokens should be >= 0 and <= total
    if [[ $used -lt 0 || $used -gt $total ]]; then
        log_fail "used_tokens out of range" "0 <= used <= total" "used=$used, total=$total"
        all_valid=false
    fi

    # Percentage should be 0-100
    if [[ $pct -lt 0 || $pct -gt 100 ]]; then
        log_fail "percentage out of range" "0-100" "$pct"
        all_valid=false
    fi

    if [[ "$all_valid" == true ]]; then
        log_pass "All values in valid range (used=$used, total=$total, pct=$pct%)"
    fi
}

test_percentage_calculation() {
    log_test "Percentage calculation is correct"

    if [[ ! -f "$CACHE_FILE" ]]; then
        log_skip "Cache file doesn't exist"
        return
    fi

    local used=$(jq -r '.used_tokens // 0' "$CACHE_FILE")
    local total=$(jq -r '.total_tokens // 1' "$CACHE_FILE")
    local pct=$(jq -r '.percentage // 0' "$CACHE_FILE")

    if [[ $total -eq 0 ]]; then
        log_skip "Total tokens is 0"
        return
    fi

    local expected_pct=$((used * 100 / total))
    local diff=$((pct - expected_pct))
    [[ $diff -lt 0 ]] && diff=$((-diff))

    # Allow 1% tolerance for rounding
    if [[ $diff -le 1 ]]; then
        log_pass "Percentage calculation correct (stored: $pct%, calculated: $expected_pct%)"
    else
        log_fail "Percentage mismatch" "$expected_pct%" "$pct% (diff: $diff%)"
    fi
}

# ============================================
# VALIDATION AGAINST /CONTEXT
# ============================================

validate_against_context() {
    local context_used="${1:-}"
    local context_total="${2:-}"
    local context_pct="${3:-}"

    echo -e "${CYAN}═══════════════════════════════════════════════════════════${RESET}"
    echo -e "${CYAN}Context Validation Against /context Command${RESET}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════${RESET}"
    echo ""

    if [[ ! -f "$CACHE_FILE" ]]; then
        echo -e "${RED}✗ No cache file found${RESET}"
        echo "  Run a Claude Code session first to generate context data"
        exit 1
    fi

    # Get statusline values from cache
    local statusline_used=$(jq -r '.used_tokens // 0' "$CACHE_FILE")
    local statusline_total=$(jq -r '.total_tokens // 0' "$CACHE_FILE")
    local statusline_pct=$(jq -r '.percentage // 0' "$CACHE_FILE")

    echo -e "${YELLOW}Statusline values (from cache):${RESET}"
    echo -e "  Used: ${statusline_used} tokens"
    echo -e "  Total: ${statusline_total} tokens"
    echo -e "  Percentage: ${statusline_pct}%"
    echo ""

    # If /context values provided, compare
    if [[ -n "$context_used" && -n "$context_total" && -n "$context_pct" ]]; then
        echo -e "${YELLOW}/context values (provided):${RESET}"
        echo -e "  Used: ${context_used} tokens"
        echo -e "  Total: ${context_total} tokens"
        echo -e "  Percentage: ${context_pct}%"
        echo ""

        echo -e "${CYAN}───────────────────────────────────────────────────────────${RESET}"
        echo -e "${YELLOW}Comparison Results:${RESET}"

        local all_match=true

        # Compare total tokens (should be exact match)
        if [[ $context_total -eq $statusline_total ]]; then
            echo -e "  Total tokens:  ${GREEN}✓ MATCH${RESET} ($context_total)"
        else
            echo -e "  Total tokens:  ${RED}✗ MISMATCH${RESET} (/context: $context_total, statusline: $statusline_total)"
            all_match=false
        fi

        # Compare used tokens (allow small tolerance for timing)
        local used_diff=$((context_used - statusline_used))
        [[ $used_diff -lt 0 ]] && used_diff=$((-used_diff))
        local used_tolerance=$((context_total / 100))  # 1% tolerance

        if [[ $used_diff -le $used_tolerance ]]; then
            echo -e "  Used tokens:   ${GREEN}✓ MATCH${RESET} (within ${used_tolerance} tolerance)"
        else
            echo -e "  Used tokens:   ${RED}✗ MISMATCH${RESET} (diff: $used_diff tokens)"
            all_match=false
        fi

        # Compare percentage (allow 1% tolerance)
        local pct_diff=$((context_pct - statusline_pct))
        [[ $pct_diff -lt 0 ]] && pct_diff=$((-pct_diff))

        if [[ $pct_diff -le 1 ]]; then
            echo -e "  Percentage:    ${GREEN}✓ MATCH${RESET} (within 1% tolerance)"
        else
            echo -e "  Percentage:    ${RED}✗ MISMATCH${RESET} (diff: ${pct_diff}%)"
            all_match=false
        fi

        echo -e "${CYAN}───────────────────────────────────────────────────────────${RESET}"

        if [[ "$all_match" == true ]]; then
            echo -e ""
            echo -e "${GREEN}✓ VALIDATION PASSED${RESET}"
            echo -e "  Statusline accurately reflects /context values"
            exit 0
        else
            echo -e ""
            echo -e "${RED}✗ VALIDATION FAILED${RESET}"
            echo -e "  Statusline does NOT match /context"
            exit 1
        fi
    else
        echo -e "${YELLOW}To validate against /context:${RESET}"
        echo ""
        echo "  1. Run ${CYAN}/context${RESET} in Claude Code"
        echo "  2. Note the values shown (e.g., '133k/200k tokens (66%)')"
        echo "  3. Run this script with those values:"
        echo ""
        echo "     ${GREEN}$0 validate 133000 200000 66${RESET}"
        echo ""
        echo -e "${DIM}Note: Values should be within 1% tolerance for PASS${RESET}"
    fi
}

# ============================================
# MAIN
# ============================================

main() {
    local command="${1:-test}"

    case "$command" in
        validate)
            validate_against_context "$2" "$3" "$4"
            ;;
        test|"")
            echo -e "${CYAN}═══════════════════════════════════════════════════════════${RESET}"
            echo -e "${CYAN}Statusline Context Unit Tests${RESET}"
            echo -e "${CYAN}═══════════════════════════════════════════════════════════${RESET}"
            echo ""

            test_cache_file_exists
            test_cache_file_valid_json
            test_cache_has_required_fields
            test_values_in_valid_range
            test_percentage_calculation
            test_remaining_percentage_matches

            echo ""
            echo -e "${CYAN}───────────────────────────────────────────────────────────${RESET}"
            echo -e "${YELLOW}Results: ${GREEN}${TESTS_PASSED} passed${RESET}, ${RED}${TESTS_FAILED} failed${RESET}, ${DIM}${TESTS_TOTAL} total${RESET}"
            echo -e "${CYAN}───────────────────────────────────────────────────────────${RESET}"

            if [[ $TESTS_FAILED -gt 0 ]]; then
                exit 1
            fi
            ;;
        *)
            echo "Unknown command: $command"
            echo "Usage: $0 [test|validate] [used_tokens total_tokens percentage]"
            exit 1
            ;;
    esac
}

main "$@"
