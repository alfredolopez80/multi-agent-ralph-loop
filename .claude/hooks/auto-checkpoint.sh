#!/bin/bash
#===============================================================================
# auto-checkpoint.sh - Automatic checkpoint management based on context
#
# VERSION: 1.0.0
# DATE: 2026-02-15
# PURPOSE: Automatically save checkpoints when context reaches critical levels
# TRIGGER: PostToolUse (monitors context usage)
#
# AUTOMATION:
#   - Detects context critical level from system reminders
#   - Saves checkpoint automatically at 75%+ context usage
#   - Maintains rolling history of checkpoints
#   - Integrates with /checkpoint skill for recovery
#===============================================================================

set -e

SCRIPT_VERSION="1.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Configuration
CHECKPOINT_DIR="$PROJECT_ROOT/.ralph/checkpoints"
MAX_CHECKPOINTS=10  # Keep last 10 checkpoints
CONTEXT_THRESHOLD=75  # Save checkpoint at 75% context usage

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

#===============================================================================
# Helper Functions
#===============================================================================

log_info() {
    echo "[checkpoint] $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[checkpoint] WARNING: $1${NC}" >&2
}

get_timestamp() {
    date +%Y%m%d_%H%M%S
}

ensure_checkpoint_dir() {
    mkdir -p "$CHECKPOINT_DIR"
}

get_context_usage() {
    # Try to get context from system reminder or environment
    # This is a heuristic - actual context comes from Claude Code
    if [ -n "$CLAUDE_CONTEXT_PERCENT" ]; then
        echo "$CLAUDE_CONTEXT_PERCENT"
        return
    fi

    # Default: check for context file
    local context_file="/tmp/claude-context-$$"
    if [ -f "$context_file" ]; then
        cat "$context_file"
        return
    fi

    echo "0"
}

#===============================================================================
# Checkpoint Functions
#===============================================================================

create_checkpoint() {
    local reason="${1:-auto}"
    local timestamp=$(get_timestamp)
    local checkpoint_name="checkpoint_${timestamp}_${reason}"
    local checkpoint_file="$CHECKPOINT_DIR/${checkpoint_name}.md"

    ensure_checkpoint_dir

    # Create checkpoint content
    cat > "$checkpoint_file" << EOF
# Checkpoint: ${checkpoint_name}

**Created**: $(date -Iseconds)
**Reason**: ${reason}
**Session**: ${SESSION_ID:-unknown}

## Git Status
\`\`\`
$(cd "$PROJECT_ROOT" && git status --short 2>/dev/null || echo "Not a git repo")
\`\`\`

## Recent Changes
\`\`\`
$(cd "$PROJECT_ROOT" && git diff --stat HEAD~1 2>/dev/null | tail -5 || echo "No recent changes")
\`\`\`

## Active Files
$(cd "$PROJECT_ROOT" && git diff --name-only 2>/dev/null | head -10 || echo "None")

## Recovery Command
\`\`\`bash
# To recover this checkpoint:
/plan show           # View current plan
ralph checkpoint restore ${checkpoint_name}
\`\`\`

---
*Auto-generated by auto-checkpoint.sh v${SCRIPT_VERSION}*
EOF

    log_info "Checkpoint saved: ${checkpoint_name}"

    # Cleanup old checkpoints
    cleanup_old_checkpoints

    # Output hook response
    echo "{\"checkpoint\":\"${checkpoint_name}\",\"reason\":\"${reason}\",\"auto\":true}"
}

cleanup_old_checkpoints() {
    ensure_checkpoint_dir

    # Get list of checkpoints, sorted by date (newest first)
    local count=$(ls -1 "$CHECKPOINT_DIR"/checkpoint_*.md 2>/dev/null | wc -l | tr -d ' ')

    if [ "$count" -gt "$MAX_CHECKPOINTS" ]; then
        local to_delete=$((count - MAX_CHECKPOINTS))
        log_info "Cleaning up $to_delete old checkpoint(s)"

        ls -1t "$CHECKPOINT_DIR"/checkpoint_*.md | tail -$to_delete | while read old_checkpoint; do
            rm -f "$old_checkpoint"
            log_info "Removed: $(basename "$old_checkpoint")"
        done
    fi
}

list_checkpoints() {
    ensure_checkpoint_dir

    echo "=== Available Checkpoints ==="
    local count=0
    for checkpoint in $(ls -1t "$CHECKPOINT_DIR"/checkpoint_*.md 2>/dev/null); do
        ((count++)) || true
        local name=$(basename "$checkpoint" .md)
        local created=$(grep "^\*\*Created\*\*:" "$checkpoint" | cut -d: -f2- | xargs)
        local reason=$(grep "^\*\*Reason\*\*:" "$checkpoint" | cut -d: -f2- | xargs)
        printf "%2d. %-45s %s (%s)\n" "$count" "$name" "$created" "$reason"
    done

    if [ "$count" -eq 0 ]; then
        echo "No checkpoints found"
    fi

    echo ""
    echo "Recovery: ralph checkpoint restore <name>"
}

restore_checkpoint() {
    local checkpoint_name="$1"
    local checkpoint_file="$CHECKPOINT_DIR/${checkpoint_name}.md"

    if [ ! -f "$checkpoint_file" ]; then
        log_warn "Checkpoint not found: ${checkpoint_name}"
        list_checkpoints
        return 1
    fi

    log_info "Restoring checkpoint: ${checkpoint_name}"
    cat "$checkpoint_file"
}

#===============================================================================
# Main Hook Logic
#===============================================================================

main() {
    local mode="${1:-check}"
    local context_percent="${2:-0}"

    case "$mode" in
        --check|check)
            # Check if context is critical and save checkpoint
            if [ "$context_percent" -ge "$CONTEXT_THRESHOLD" ]; then
                create_checkpoint "context_${context_percent}pct"
            fi
            ;;

        --save|save)
            local reason="${3:-manual}"
            create_checkpoint "$reason"
            ;;

        --list|list)
            list_checkpoints
            ;;

        --restore|restore)
            restore_checkpoint "$2"
            ;;

        --cleanup|cleanup)
            cleanup_old_checkpoints
            ;;

        --help|-h)
            echo "Usage: $0 [COMMAND] [OPTIONS]"
            echo ""
            echo "Commands:"
            echo "  --check [PERCENT]   Check context and save if >= ${CONTEXT_THRESHOLD}%"
            echo "  --save [REASON]     Force save checkpoint with reason"
            echo "  --list             List all available checkpoints"
            echo "  --restore NAME     Show checkpoint details"
            echo "  --cleanup          Remove old checkpoints (keep last ${MAX_CHECKPOINTS})"
            echo ""
            echo "Environment:"
            echo "  CLAUDE_CONTEXT_PERCENT  Current context usage (0-100)"
            ;;

        *)
            # Default: check mode with context from environment
            if [ -n "$CLAUDE_CONTEXT_PERCENT" ] && [ "$CLAUDE_CONTEXT_PERCENT" -ge "$CONTEXT_THRESHOLD" ]; then
                create_checkpoint "context_${CLAUDE_CONTEXT_PERCENT}pct"
            fi
            ;;
    esac
}

# Run main if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
