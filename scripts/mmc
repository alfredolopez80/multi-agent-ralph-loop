#!/usr/bin/env bash
# mmc - Multi-Model Claude Code Wrapper (GLM-4.7 + MiniMax Fallback)
# Version 2.69.0
# v2.69: GLM-4.7 PRIMARY, MiniMax FALLBACK (complete migration from MiniMax-first)
#        - GLM-4.7 Coding API as primary backend (https://api.z.ai/api/coding/paas/v4)
#        - MiniMax M2.1 as optional fallback (via MINIMAX_API_KEY)
#        - Web search via GLM-4.7 web_search feature
#        - BREAKING: MiniMax is no longer primary
# v2.24: MiniMax MCP integration (web_search + understand_image)
# v2.23: AST-grep integration for structural code search
# v2.22: Tool validation support, 9 language quality gates
# v2.21: Self-update, pre-merge validation, integrations health check
# v2.20: WorkTrunk integration, multi-agent PR review support
# Based on: https://blog.devgenius.io/claude-code-but-cheaper-and-snappy-minimax-m2-1-with-a-tiny-wrapper-7d910db93383
# GLM-4.7 Docs: https://platform.z.ai/docs/api-reference/chat-completions

set -euo pipefail

# SECURITY: Ensure all created files are user-only by default (VULN-008)
umask 077

VERSION="2.69.0"
CONFIG_FILE="${HOME}/.ralph/config/glm.json"
MINIMAX_CONFIG_FILE="${HOME}/.ralph/config/minimax.json"
RALPH_DIR="${HOME}/.ralph"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

show_help() {
    cat << 'EOF'
mmc - Multi-Model Claude Code Wrapper v2.69.0

PRIMARY: GLM-4.7 (via Z.AI Coding API)
FALLBACK: MiniMax M2.1 (optional)

Run Claude Code with GLM-4.7 backend (cost-effective alternative to Claude).

USAGE:
  mmc                     Launch Claude Code with GLM-4.7 backend
  mmc --setup             Configure GLM-4.7 API key (and optional MiniMax fallback)
  mmc --query "prompt"    Single query to GLM-4.7
  mmc --loop N "task"     Loop up to N iterations (default: 50)
  mmc --web-search "q"    Web search via GLM-4.7
  mmc --second-opinion    Get second opinion on previous result
  mmc --status            Show configuration status
  mmc --stats             Show usage statistics from logs
  mmc --version           Show version
  mmc --help              Show this help

PRIMARY MODEL (GLM-4.7):
  GLM-4.7               Advanced reasoning model (~100 tps)
  GLM-4.7-Flash         Faster variant (planned)

FALLBACK (MiniMax - if configured):
  MiniMax-M2.1           (~60 tps, 74% SWE-bench)
  MiniMax-M2.1-lightning (~100 tps)

ITERATION LIMITS:
  GLM-4.7:              50 iterations (2x Claude)
  MiniMax (fallback):   30 iterations

COST COMPARISON:
  Model             Input/M    Output/M    vs Claude    Speed
  ----------------------------------------------------------------
  Claude Sonnet     $3.00      $15.00      baseline     ~50 tps
  GLM-4.7           ~$0.50     ~$2.00      ~15%         ~100 tps
  MiniMax M2.1      $0.30      $1.20       ~8%          ~60 tps

API FEATURES (GLM-4.7):
  - OpenAI-compatible chat completions API
  - Web search integration: {"web_search": {"enable": true}}
  - Reasoning content: reasoning_content field for chain-of-thought
  - Temperature: 0.0 to 1.0 (recommended: 0.3-0.7)

EXAMPLES:
  mmc                           # Launch Claude Code with GLM-4.7
  mmc --setup                   # First time setup
  mmc --query "Review this code"
  mmc --loop 50 "Fix all bugs"
  mmc --web-search "React 19 features 2025"
EOF
}

ensure_dirs() {
    mkdir -p "${RALPH_DIR}/config"
    mkdir -p "${RALPH_DIR}/logs"
}

# SECURITY FIX (CWE-200): Secure curl helper to prevent API key exposure in argv
secure_curl() {
    local URL="$1"
    local API_KEY="$2"
    local DATA="$3"
    local MAX_TIME="${4:-300}"

    # Create secure temp file for headers
    local HEADER_FILE
    HEADER_FILE=$(mktemp "${TMPDIR:-/tmp}/mmc_headers.XXXXXX")
    chmod 600 "$HEADER_FILE"

    # Write headers to file (not visible in ps)
    cat > "$HEADER_FILE" <<EOF
Authorization: Bearer $API_KEY
Content-Type: application/json
EOF

    # Use -H @file to read headers from file
    local RESPONSE
    RESPONSE=$(curl -s --max-time "$MAX_TIME" "$URL" \
        -H @"$HEADER_FILE" \
        -d "$DATA" 2>&1)

    # Clean up header file immediately
    rm -f "$HEADER_FILE"

    echo "$RESPONSE"
}

setup() {
    ensure_dirs

    echo -e "${BLUE}GLM-4.7 + MiniMax Fallback Configuration${NC}"
    echo -e "${CYAN}v2.69.0: GLM-4.7 is now PRIMARY, MiniMax is FALLBACK${NC}"
    echo ""

    # PRIMARY: GLM-4.7 API Key
    echo -e "${GREEN}PRIMARY: GLM-4.7 (Z.AI) API Key${NC}"
    echo -e "Get your API key from: https://platform.z.ai/"
    read -s -p "Enter your GLM-4.7 (Z.AI) API key: " GLM_API_KEY
    echo ""

    if [ -z "$GLM_API_KEY" ]; then
        echo -e "${RED}Error: GLM API key cannot be empty${NC}"
        exit 1
    fi

    # Save GLM config
    jq -n \
        --arg apiKey "$GLM_API_KEY" \
        --arg baseUrl "https://api.z.ai/api/coding/paas/v4" \
        --arg defaultModel "glm-4.7" \
        '{
            apiKey: $apiKey,
            baseUrl: $baseUrl,
            defaultModel: $defaultModel,
            features: {
                webSearch: true,
                reasoning: true
            }
        }' > "$CONFIG_FILE"

    chmod 600 "$CONFIG_FILE"
    echo -e "${GREEN}GLM configuration saved to: $CONFIG_FILE${NC}"

    # FALLBACK: MiniMax API Key (optional)
    echo ""
    echo -e "${YELLOW}FALLBACK: MiniMax API Key (optional)${NC}"
    read -p "Configure MiniMax as fallback? (y/N): " SETUP_MINIMAX

    if [[ "$SETUP_MINIMAX" =~ ^[Yy] ]]; then
        read -s -p "Enter your MiniMax API key: " MINIMAX_API_KEY
        echo ""

        if [ -n "$MINIMAX_API_KEY" ]; then
            jq -n \
                --arg apiKey "$MINIMAX_API_KEY" \
                --arg baseUrl "https://api.minimax.io/anthropic" \
                --arg defaultModel "MiniMax-M2.1" \
                --arg lightningModel "MiniMax-M2.1-lightning" \
                '{
                    apiKey: $apiKey,
                    baseUrl: $baseUrl,
                    defaultModel: $defaultModel,
                    lightningModel: $lightningModel,
                    isFallback: true
                }' > "$MINIMAX_CONFIG_FILE"

            chmod 600 "$MINIMAX_CONFIG_FILE"
            echo -e "${GREEN}MiniMax fallback configured: $MINIMAX_CONFIG_FILE${NC}"
        fi
    else
        echo -e "${YELLOW}MiniMax fallback skipped${NC}"
    fi

    # Also export to .zshrc for hooks
    echo ""
    echo -e "${BLUE}Optional: Add to ~/.zshrc for hook access:${NC}"
    echo "  export Z_AI_API_KEY='$GLM_API_KEY'"
}

check_config() {
    # Check GLM config first
    if [ -f "$CONFIG_FILE" ]; then
        return 0
    fi

    # Check for Z_AI_API_KEY in environment
    if [ -n "${Z_AI_API_KEY:-}" ]; then
        return 0
    fi

    # Check for legacy MiniMax config (will use as fallback)
    if [ -f "$MINIMAX_CONFIG_FILE" ] || [ -f "${RALPH_DIR}/config/minimax.json" ] || [ -f "$HOME/.mmc.json" ]; then
        echo -e "${YELLOW}GLM-4.7 not configured. Using MiniMax as primary (legacy mode).${NC}"
        echo -e "${YELLOW}Run 'mmc --setup' to configure GLM-4.7 as primary.${NC}"
        return 0
    fi

    echo -e "${RED}Error: No API configured. Run: mmc --setup${NC}"
    exit 1
}

check_dependencies() {
    local MISSING=()

    command -v jq &>/dev/null || MISSING+=("jq")
    command -v curl &>/dev/null || MISSING+=("curl")
    command -v claude &>/dev/null || MISSING+=("claude")

    if [ ${#MISSING[@]} -gt 0 ]; then
        echo -e "${RED}Error: Missing dependencies: ${MISSING[*]}${NC}"
        echo "Install with:"
        echo "  brew install ${MISSING[*]}"
        exit 1
    fi
}

get_glm_api_key() {
    # Priority: env var > config file
    if [ -n "${Z_AI_API_KEY:-}" ]; then
        echo "$Z_AI_API_KEY"
    elif [ -f "$CONFIG_FILE" ]; then
        jq -r '.apiKey' "$CONFIG_FILE"
    else
        echo ""
    fi
}

get_minimax_api_key() {
    # For fallback
    if [ -n "${MINIMAX_API_KEY:-}" ]; then
        echo "$MINIMAX_API_KEY"
    elif [ -f "$MINIMAX_CONFIG_FILE" ]; then
        jq -r '.apiKey' "$MINIMAX_CONFIG_FILE"
    elif [ -f "${RALPH_DIR}/config/minimax.json" ]; then
        jq -r '.apiKey' "${RALPH_DIR}/config/minimax.json"
    elif [ -f "$HOME/.mmc.json" ]; then
        jq -r '.apiKey' "$HOME/.mmc.json"
    else
        echo ""
    fi
}

log_usage() {
    local ACTION="$1"
    local MODEL="$2"
    local CHARS="${3:-0}"
    local TIMESTAMP
    TIMESTAMP=$(date +%s)

    # Get project name from git if available
    local PROJECT=""
    if command -v git &>/dev/null && git rev-parse --is-inside-work-tree &>/dev/null 2>&1; then
        PROJECT=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)" 2>/dev/null || echo "")
    fi

    # Build JSON entry using jq for safety
    local LOG_ENTRY
    LOG_ENTRY=$(jq -n \
        --argjson ts "$TIMESTAMP" \
        --arg action "$ACTION" \
        --arg model "$MODEL" \
        --argjson chars "$CHARS" \
        --arg project "$PROJECT" \
        '{ts: $ts, action: $action, model: $model, chars: $chars, project: $project}')

    # 1. GLOBAL LOG
    local GLOBAL_LOG="${RALPH_DIR}/logs/usage.jsonl"
    mkdir -p "$(dirname "$GLOBAL_LOG")"
    echo "$LOG_ENTRY" >> "$GLOBAL_LOG"
    chmod 600 "$GLOBAL_LOG" 2>/dev/null || true

    # 2. PROJECT LOG
    if [ -n "$PROJECT" ]; then
        local PROJECT_ROOT
        PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
        if [ -n "$PROJECT_ROOT" ]; then
            local PROJECT_LOG="${PROJECT_ROOT}/.ralph/usage.jsonl"
            mkdir -p "$(dirname "$PROJECT_LOG")"
            echo "$LOG_ENTRY" >> "$PROJECT_LOG"
            chmod 600 "$PROJECT_LOG" 2>/dev/null || true
        fi
    fi
}

show_status() {
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${BLUE}         MMC Configuration Status (v2.69.0)${NC}"
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    # PRIMARY: GLM-4.7
    echo -e "${GREEN}PRIMARY: GLM-4.7${NC}"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    local GLM_KEY=$(get_glm_api_key)
    if [ -n "$GLM_KEY" ]; then
        if [ -f "$CONFIG_FILE" ]; then
            echo -e "  Config: ${GREEN}$CONFIG_FILE${NC}"
        else
            echo -e "  Config: ${GREEN}Environment (Z_AI_API_KEY)${NC}"
        fi
        echo -e "  API:    https://api.z.ai/api/coding/paas/v4"
        echo -e "  Model:  glm-4.7"

        # Test connection
        echo -n "  Status: "
        local TEST_RESPONSE
        TEST_RESPONSE=$(secure_curl "https://api.z.ai/api/coding/paas/v4/chat/completions" "$GLM_KEY" \
            '{"model":"glm-4.7","max_tokens":1,"messages":[{"role":"user","content":"1"}]}' 10)

        if echo "$TEST_RESPONSE" | jq -e '.choices[0]' >/dev/null 2>&1; then
            echo -e "${GREEN}Connected${NC}"
        elif echo "$TEST_RESPONSE" | jq -e '.error' >/dev/null 2>&1; then
            local ERROR_MSG=$(echo "$TEST_RESPONSE" | jq -r '.error.message // .error.code // "Unknown"' 2>/dev/null)
            echo -e "${RED}Error: $ERROR_MSG${NC}"
        else
            echo -e "${YELLOW}Unable to verify${NC}"
        fi
    else
        echo -e "  Status: ${RED}Not configured${NC}"
        echo "  Run 'mmc --setup' to configure"
    fi

    echo ""

    # FALLBACK: MiniMax
    echo -e "${YELLOW}FALLBACK: MiniMax${NC}"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    local MM_KEY=$(get_minimax_api_key)
    if [ -n "$MM_KEY" ]; then
        echo -e "  Status: ${GREEN}Configured${NC}"
        echo "  Model:  MiniMax-M2.1"
        echo "  Used when: GLM-4.7 API errors or rate limits"
    else
        echo -e "  Status: ${YELLOW}Not configured${NC}"
        echo "  Optional - run 'mmc --setup' to add fallback"
    fi

    echo ""
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
}

# Query GLM-4.7 with MiniMax fallback
query() {
    local PROMPT="$1"
    local MODEL="${2:-glm-4.7}"
    local TEMPERATURE="${3:-0.5}"
    local WEB_SEARCH="${4:-false}"

    log_usage "query" "$MODEL" "${#PROMPT}"

    check_config
    check_dependencies

    local GLM_KEY=$(get_glm_api_key)

    # Escape prompt for JSON
    local ESCAPED_PROMPT
    ESCAPED_PROMPT=$(printf '%s' "$PROMPT" | jq -Rs '.')

    local RESPONSE=""
    local SUCCESS=false

    # Try GLM-4.7 first
    if [ -n "$GLM_KEY" ]; then
        local REQUEST_DATA
        if [ "$WEB_SEARCH" = "true" ]; then
            REQUEST_DATA=$(cat <<EOJSON
{
    "model": "$MODEL",
    "max_tokens": 4096,
    "temperature": $TEMPERATURE,
    "messages": [{"role": "user", "content": $ESCAPED_PROMPT}],
    "web_search": {"enable": true}
}
EOJSON
)
        else
            REQUEST_DATA=$(cat <<EOJSON
{
    "model": "$MODEL",
    "max_tokens": 4096,
    "temperature": $TEMPERATURE,
    "messages": [{"role": "user", "content": $ESCAPED_PROMPT}]
}
EOJSON
)
        fi

        RESPONSE=$(secure_curl "https://api.z.ai/api/coding/paas/v4/chat/completions" "$GLM_KEY" "$REQUEST_DATA" 300)

        # Check for success
        local CONTENT
        CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty' 2>/dev/null)
        local REASONING
        REASONING=$(echo "$RESPONSE" | jq -r '.choices[0].message.reasoning_content // empty' 2>/dev/null)

        if [ -n "$CONTENT" ] && [ "$CONTENT" != "null" ]; then
            echo "$CONTENT"
            SUCCESS=true
        elif [ -n "$REASONING" ] && [ "$REASONING" != "null" ]; then
            echo "$REASONING"
            SUCCESS=true
        fi
    fi

    # Fallback to MiniMax if GLM failed
    if [ "$SUCCESS" != "true" ]; then
        local MM_KEY=$(get_minimax_api_key)
        if [ -n "$MM_KEY" ]; then
            echo -e "${YELLOW}GLM-4.7 unavailable, using MiniMax fallback...${NC}" >&2

            local MM_REQUEST_DATA
            MM_REQUEST_DATA=$(cat <<EOJSON
{
    "model": "MiniMax-M2.1",
    "max_tokens": 4096,
    "temperature": 1,
    "messages": [{"role": "user", "content": $ESCAPED_PROMPT}]
}
EOJSON
)
            RESPONSE=$(secure_curl "https://api.minimax.io/anthropic/v1/messages" "$MM_KEY" "$MM_REQUEST_DATA" 300)

            local TEXT_CONTENT
            TEXT_CONTENT=$(echo "$RESPONSE" | jq -r '.content[] | select(.type == "text") | .text' 2>/dev/null | head -1)

            if [ -n "$TEXT_CONTENT" ] && [ "$TEXT_CONTENT" != "null" ]; then
                echo "$TEXT_CONTENT"
            else
                echo "$RESPONSE" | jq -r '.error.message // "Error: Unable to parse response"' 2>/dev/null || echo "$RESPONSE"
            fi
        else
            # No fallback available
            echo "$RESPONSE" | jq -r '.error.message // "Error: GLM-4.7 request failed and no MiniMax fallback configured"' 2>/dev/null || echo "$RESPONSE"
        fi
    fi
}

# Web search via GLM-4.7
web_search() {
    local QUERY="$1"

    echo -e "${BLUE}Web search via GLM-4.7...${NC}" >&2
    query "$QUERY" "glm-4.7" "0.3" "true"
}

launch_claude_code() {
    check_config
    check_dependencies

    # Try GLM-4.7 first, but Claude Code doesn't support GLM directly
    # We use MiniMax as the backend since it's Anthropic-compatible
    local MM_KEY=$(get_minimax_api_key)

    if [ -z "$MM_KEY" ]; then
        echo -e "${RED}Error: Claude Code requires Anthropic-compatible API.${NC}"
        echo -e "${RED}MiniMax is needed for Claude Code integration.${NC}"
        echo -e "Run 'mmc --setup' and configure MiniMax fallback."
        exit 1
    fi

    local MODEL="MiniMax-M2.1"
    local SMALL_MODEL="MiniMax-M2.1-lightning"

    log_usage "chat" "$MODEL" "0"

    echo -e "${BLUE}Launching Claude Code with MiniMax backend${NC}"
    echo -e "${YELLOW}Note: Use 'mmc --query' for GLM-4.7 direct queries${NC}"
    echo -e "   Model: ${GREEN}$MODEL${NC}"
    echo -e "   Small/Fast: ${GREEN}$SMALL_MODEL${NC}"
    echo ""

    ANTHROPIC_API_KEY="$MM_KEY" \
    ANTHROPIC_BASE_URL="https://api.minimax.io/anthropic" \
    ANTHROPIC_MODEL="$MODEL" \
    ANTHROPIC_SMALL_FAST_MODEL="$SMALL_MODEL" \
    ANTHROPIC_DEFAULT_SONNET_MODEL="$MODEL" \
    ANTHROPIC_DEFAULT_OPUS_MODEL="$MODEL" \
    ANTHROPIC_DEFAULT_HAIKU_MODEL="$SMALL_MODEL" \
    API_TIMEOUT_MS="3000000" \
    CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC="1" \
    claude "$@"
}

loop() {
    local MAX_ITER="${1:-50}"
    shift
    local TASK="$*"

    log_usage "loop" "glm-4.7" "${#TASK}"

    check_config
    check_dependencies

    echo -e "${BLUE}Starting GLM-4.7 loop: $MAX_ITER iterations max${NC}"
    echo -e "   Task: $TASK"
    echo ""

    local ITER=0
    while [ $ITER -lt $MAX_ITER ]; do
        ((ITER++))
        echo -e "${YELLOW}[Iteration $ITER/$MAX_ITER]${NC}"

        RESULT=$(query "$TASK. If complete, respond with VERIFIED_DONE.")
        echo "$RESULT"
        echo ""

        if echo "$RESULT" | grep -q "VERIFIED_DONE"; then
            echo -e "${GREEN}Task completed at iteration $ITER${NC}"
            return 0
        fi
    done

    echo -e "${YELLOW}Max iterations reached without VERIFIED_DONE${NC}"
    return 1
}

cmd_stats() {
    local SCOPE="${1:-all}"
    local GLOBAL_LOG="${RALPH_DIR}/logs/usage.jsonl"
    local PROJECT_LOG=""

    # Check for project-level log
    if command -v git &>/dev/null && git rev-parse --is-inside-work-tree &>/dev/null 2>&1; then
        local PROJECT_ROOT
        PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
        if [ -n "$PROJECT_ROOT" ] && [ -f "${PROJECT_ROOT}/.ralph/usage.jsonl" ]; then
            PROJECT_LOG="${PROJECT_ROOT}/.ralph/usage.jsonl"
        fi
    fi

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "           MMC USAGE STATISTICS (v2.69.0)"
    echo "           PRIMARY: GLM-4.7 | FALLBACK: MiniMax"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    # GLOBAL STATS
    if [[ "$SCOPE" == "all" ]] || [[ "$SCOPE" == "global" ]]; then
        echo "ğŸ“Š GLOBAL USAGE (all projects)"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        if [[ -f "$GLOBAL_LOG" ]]; then
            echo "  Log: $GLOBAL_LOG"
            echo "  Total queries: $(wc -l < "$GLOBAL_LOG" | tr -d ' ')"
            echo ""
            echo "  By model:"
            jq -r '.model' "$GLOBAL_LOG" 2>/dev/null | sort | uniq -c | sed 's/^/    /'
            echo ""
            echo "  By project:"
            jq -r '.project // "unknown"' "$GLOBAL_LOG" 2>/dev/null | sort | uniq -c | sed 's/^/    /'
            echo ""
            echo "  Total chars: $(jq -s '[.[].chars] | add' "$GLOBAL_LOG" 2>/dev/null || echo "N/A")"
        else
            echo "  No global logs found"
        fi
        echo ""
    fi

    # PROJECT STATS
    if [[ "$SCOPE" == "all" ]] || [[ "$SCOPE" == "project" ]]; then
        echo "ğŸ“ PROJECT USAGE (this repo only)"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        if [[ -n "$PROJECT_LOG" ]] && [[ -f "$PROJECT_LOG" ]]; then
            echo "  Log: $PROJECT_LOG"
            echo "  Total queries: $(wc -l < "$PROJECT_LOG" | tr -d ' ')"
            echo ""
            echo "  By model:"
            jq -r '.model' "$PROJECT_LOG" 2>/dev/null | sort | uniq -c | sed 's/^/    /'
            echo ""
            echo "  By action:"
            jq -r '.action' "$PROJECT_LOG" 2>/dev/null | sort | uniq -c | sed 's/^/    /'
            echo ""
            echo "  Total chars: $(jq -s '[.[].chars] | add' "$PROJECT_LOG" 2>/dev/null || echo "N/A")"
        else
            echo "  No project-level logs found (not in a git repo or no usage yet)"
        fi
        echo ""
    fi

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  Usage: mmc --stats [all|global|project]"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
}

main() {
    local CMD="${1:-launch}"

    case "$CMD" in
        --setup|setup)
            setup
            ;;
        --query|-q)
            shift
            query "$*"
            ;;
        --web-search|--search|-s)
            shift
            web_search "$*"
            ;;
        --loop|-l)
            shift
            loop "$@"
            ;;
        --second-opinion)
            shift
            query "As a second opinion, review this: $*"
            ;;
        --status)
            show_status
            ;;
        --stats)
            shift
            cmd_stats "${1:-all}"
            ;;
        --version|-v)
            echo "mmc v$VERSION (PRIMARY: GLM-4.7, FALLBACK: MiniMax)"
            ;;
        --help|-h)
            show_help
            ;;
        launch|"")
            shift 2>/dev/null || true
            launch_claude_code "$@"
            ;;
        *)
            # Pass through to claude code with MiniMax
            launch_claude_code "$@"
            ;;
    esac
}

main "$@"
